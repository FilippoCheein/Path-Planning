    nObst=randi(10);
    yVec=randperm(100,2+nObst);
    xVec=randperm(100,2+nObst);
    LoggedSignals.State=[yVec(1),xVec(1)];
    LoggedSignals.Goal=[yVec(2),xVec(2)];
    LoggedSignals.Obst=[yVec(3:end).',xVec(3:end).'];
    
% function [uField]=localU(LoggedSignals,localR)
    kAtt=1;
    kRep=20;
    rRep=3;
    
    [x,y]=meshgrid(1:100,1:100);
    yDiff=y-LoggedSignals.Goal(1)+.01;
    xDiff=x-LoggedSignals.Goal(2)+.01;
    
    uAtt=0.5*kAtt*(yDiff.^2+xDiff.^2);
    
    uRep=zeros(100);
    regions=zeros(100);
    figure(1)
    tiledlayout(2,1,'TileSpacing','tight','Padding','tight')
    nexttile
    for n=1:size(LoggedSignals.Obst,1)
        currY=(1./yDiff-1/rRep);
        currX=1./xDiff-1/rRep;
        currRep=0.5*kRep*(1./norm(yDiff+xDiuf+1./xDiff-1/rRep).^2;
        currStep=sqrt((y-LoggedSignals.Obst(n,1)).^2+(x-LoggedSignals.Obst(n,2)).^2)<=rRep;
        uRep=uRep+currRep*currStep;
        regions=imoverlay(regions,currStep);
        imshow(regions)
    end
    uField=uAtt+uRep;
    
    nexttile
    mesh(uRep)
    shading interp
    colormap parula
    
% end